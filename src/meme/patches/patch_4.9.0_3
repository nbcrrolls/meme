diff -r 1f1e06a05c93 -r d93b2a812916 etc/centrimo_config.xml.in
--- a/etc/centrimo_config.xml.in	Thu Nov 08 12:00:17 2012 +1000
+++ b/etc/centrimo_config.xml.in	Tue Nov 13 19:30:07 2012 +1000
@@ -1,6 +1,6 @@
 <appConfig xmlns="http://nbcr.sdsc.edu/opal/types" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <metadata appName="CENTRIMO_@SERVICE_VERSION@">
-    <usage>Determine which motifs occur centrally in ChIP-seq output.</usage>
+    <usage>CentriMo: Determine which motifs occur centrally in ChIP-seq output.</usage>
     <info>
     <![CDATA[
       centrimo_webservice [options] <sequences file> <motif databases>
diff -r 1f1e06a05c93 -r d93b2a812916 etc/dreme_config.xml.in
--- a/etc/dreme_config.xml.in	Thu Nov 08 12:00:17 2012 +1000
+++ b/etc/dreme_config.xml.in	Tue Nov 13 19:30:07 2012 +1000
@@ -1,6 +1,6 @@
 <appConfig xmlns="http://nbcr.sdsc.edu/opal/types" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <metadata appName="DREME_@SERVICE_VERSION@">
-    <usage>Discovers regular expression motifs</usage>
+    <usage>DREME: Discovers regular expression motifs</usage>
     <info>
     <![CDATA[
     dreme_webservice [options] <positive sequences file>
diff -r 1f1e06a05c93 -r d93b2a812916 etc/fimo_config.xml.in
--- a/etc/fimo_config.xml.in	Thu Nov 08 12:00:17 2012 +1000
+++ b/etc/fimo_config.xml.in	Tue Nov 13 19:30:07 2012 +1000
@@ -1,6 +1,6 @@
 <appConfig xmlns="http://nbcr.sdsc.edu/opal/types" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <metadata appName="FIMO_@SERVICE_VERSION@">
-    <usage>Search sequences for individual motif sites</usage>
+    <usage>FIMO: Search sequences for individual motif sites</usage>
     <info xsd:type="xsd:string">
     <![CDATA[
     fimo_webservice [options] <motifs> <db seqs>
diff -r 1f1e06a05c93 -r d93b2a812916 etc/glam2_config.xml.in
--- a/etc/glam2_config.xml.in	Thu Nov 08 12:00:17 2012 +1000
+++ b/etc/glam2_config.xml.in	Tue Nov 13 19:30:07 2012 +1000
@@ -1,6 +1,6 @@
 <appConfig xmlns="http://nbcr.sdsc.edu/opal/types" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <metadata appName="GLAM2_@SERVICE_VERSION@">
-    <usage>Find gapped local alignment motifs</usage>
+    <usage>GLAM2: Find gapped local alignment motifs</usage>
     <info xsd:type="xsd:string">
     <![CDATA[
     glam2_webservice [options] <sequences>
diff -r 1f1e06a05c93 -r d93b2a812916 etc/glam2scan_config.xml.in
--- a/etc/glam2scan_config.xml.in	Thu Nov 08 12:00:17 2012 +1000
+++ b/etc/glam2scan_config.xml.in	Tue Nov 13 19:30:07 2012 +1000
@@ -1,6 +1,6 @@
 <appConfig xmlns="http://nbcr.sdsc.edu/opal/types" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <metadata appName="GLAM2SCAN_@SERVICE_VERSION@">
-    <usage>Find GLAM2 motifs in sequences</usage>
+    <usage>GLAM2SCAN: Find GLAM2 motifs in sequences</usage>
     <info xsd:type="xsd:string">
     <![CDATA[
     glam2scan_webservice [options] <glam2 alignment> <db sequences>
diff -r 1f1e06a05c93 -r d93b2a812916 etc/gomo_config.xml.in
--- a/etc/gomo_config.xml.in	Thu Nov 08 12:00:17 2012 +1000
+++ b/etc/gomo_config.xml.in	Tue Nov 13 19:30:07 2012 +1000
@@ -1,6 +1,6 @@
 <appConfig xmlns="http://nbcr.sdsc.edu/opal/types" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <metadata appName="GOMO_@SERVICE_VERSION@">
-    <usage>Find Gene Ontology roles for motifs</usage>
+    <usage>GOMO: Find Gene Ontology roles for motifs</usage>
     <info xsd:type="xsd:string">
     <![CDATA[
     gomo_webservice [options] <motif> <databases>
diff -r 1f1e06a05c93 -r d93b2a812916 etc/mast_config.xml.in
--- a/etc/mast_config.xml.in	Thu Nov 08 12:00:17 2012 +1000
+++ b/etc/mast_config.xml.in	Tue Nov 13 19:30:07 2012 +1000
@@ -1,6 +1,6 @@
 <appConfig xmlns="http://nbcr.sdsc.edu/opal/types" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <metadata appName="MAST_@SERVICE_VERSION@">
-    <usage>Search for groups of motifs in sequence databases</usage>
+    <usage>MAST: Search for groups of motifs in sequence databases</usage>
     <info xsd:type="xsd:string">
     <![CDATA[    
     mast_webservice [options] <motifs file> [<sequence database>]
diff -r 1f1e06a05c93 -r d93b2a812916 etc/mcast_config.xml.in
--- a/etc/mcast_config.xml.in	Thu Nov 08 12:00:17 2012 +1000
+++ b/etc/mcast_config.xml.in	Tue Nov 13 19:30:07 2012 +1000
@@ -1,6 +1,6 @@
 <appConfig xmlns="http://nbcr.sdsc.edu/opal/types" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <metadata appName="MCAST_@SERVICE_VERSION@">
-    <usage>Find clusters of motifs</usage>
+    <usage>MCAST: Find clusters of motifs</usage>
     <info xsd:type="xsd:string">
     <![CDATA[
     mcast_webservice [options] <motifs> <sequence db>
diff -r 1f1e06a05c93 -r d93b2a812916 etc/meme-chip_config.xml.in
--- a/etc/meme-chip_config.xml.in	Thu Nov 08 12:00:17 2012 +1000
+++ b/etc/meme-chip_config.xml.in	Tue Nov 13 19:30:07 2012 +1000
@@ -1,6 +1,6 @@
 <appConfig xmlns="http://nbcr.sdsc.edu/opal/types" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <metadata appName="MEMECHIP_@SERVICE_VERSION@">
-    <usage>Run MEME, DREME, TOMTOM and some other MEME Suite programs on ChIP-seq data</usage>
+    <usage>MEME-ChIP: Run MEME, DREME, TOMTOM and some other MEME Suite programs on ChIP-seq data</usage>
     <info xsd:type="xsd:string">
     <![CDATA[
     meme-chip_webservice [options] <sequences file> <motif databases>
diff -r 1f1e06a05c93 -r d93b2a812916 etc/meme_config.xml.in
--- a/etc/meme_config.xml.in	Thu Nov 08 12:00:17 2012 +1000
+++ b/etc/meme_config.xml.in	Tue Nov 13 19:30:07 2012 +1000
@@ -1,6 +1,6 @@
 <appConfig xmlns="http://nbcr.sdsc.edu/opal/types" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <metadata appName="MEME_@SERVICE_VERSION@">
-    <usage>Discovers motifs</usage>
+    <usage>MEME: Discovers motifs</usage>
     <info>
     <![CDATA[
     meme_webservice [options] <sequences>
diff -r 1f1e06a05c93 -r d93b2a812916 etc/spamo_config.xml.in
--- a/etc/spamo_config.xml.in	Thu Nov 08 12:00:17 2012 +1000
+++ b/etc/spamo_config.xml.in	Tue Nov 13 19:30:07 2012 +1000
@@ -1,6 +1,6 @@
 <appConfig xmlns="http://nbcr.sdsc.edu/opal/types" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <metadata appName="SPAMO_@SERVICE_VERSION@">
-    <usage>Find co-factor motifs by looking for motifs which appear at significant spacings to a primary motif</usage>
+    <usage>SpaMo: Find co-factor motifs by looking for motifs which appear at significant spacings to a primary motif</usage>
     <info>
     <![CDATA[
     spamo_webservice [options] <sequences file> <primary motif> <secondary db patterns>
diff -r 1f1e06a05c93 -r d93b2a812916 etc/tomtom_config.xml.in
--- a/etc/tomtom_config.xml.in	Thu Nov 08 12:00:17 2012 +1000
+++ b/etc/tomtom_config.xml.in	Tue Nov 13 19:30:07 2012 +1000
@@ -1,6 +1,6 @@
 <appConfig xmlns="http://nbcr.sdsc.edu/opal/types" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <metadata appName="TOMTOM_@SERVICE_VERSION@">
-    <usage>Search for similar motifs in motif databases</usage>
+    <usage>Tomtom: Search for similar motifs in motif databases</usage>
     <info>
     <![CDATA[
     tomtom_webservice [options] <query motifs> <motif databases>
diff -r 1f1e06a05c93 -r d93b2a812916 src/json-writer.c
--- a/src/json-writer.c	Thu Nov 08 12:00:17 2012 +1000
+++ b/src/json-writer.c	Tue Nov 13 19:30:07 2012 +1000
@@ -156,8 +156,9 @@
             "a following byte of a UTF-8 multibyte.");
         codepoint = codepoint | (((uint32_t)(byte & 0x3F)) << (6 * (bytes - i - 1)));
       }
-      // check for overlong representations
-      if (codepoint < (1 << (6 * (bytes - 1) + (7 - bytes)))) {
+      // check for overlong representations by seeing if we could have represented
+      // the number with one less byte
+      if (codepoint < (1 << (bytes == 2 ? 7 : (6 * (bytes - 2) + (8 - bytes))))) {
         die("The UTF-8 multibyte uses too many bytes for the codepoint it represents.");
       }
     } else { // ASCII byte
diff -r 1f1e06a05c93 -r d93b2a812916 src/mast2txt.c
--- a/src/mast2txt.c	Thu Nov 08 12:00:17 2012 +1000
+++ b/src/mast2txt.c	Tue Nov 13 19:30:07 2012 +1000
@@ -112,7 +112,7 @@
   char *name;
   char *last_mod_date;
   int seq_count;
-  long residue_count;
+  long long residue_count;
   int is_dna;
 };
 
@@ -163,8 +163,8 @@
 
 typedef struct hit HIT_T;
 struct hit {
-  long pos;
-  long gap;
+  long long pos;
+  long long gap;
   int strand;
   MAST_MOTIF_T *motif;
   double pvalue;
@@ -174,7 +174,7 @@
 
 typedef struct seg SEG_T;
 struct seg {
-  long start;
+  long long start;
   char *data;
   int length;
   HIT_T **hits;
@@ -188,7 +188,7 @@
   int num;
   char *name;
   char *comment;
-  long length;
+  long long length;
   int known;
   int has_score1;
   SCORE_T score1; //for the forward strand or both
@@ -327,7 +327,7 @@
     fprintf(mast_out,"\tDATABASE %s (%s)\n", db->name, dbtype);
     fprintf(mast_out,"\tLast updated on %s\n", db->last_mod_date);
     /* print number of sequences in database */
-    fprintf(mast_out,"\tDatabase contains %d sequences, %ld residues\n\n", db->seq_count, db->residue_count);
+    fprintf(mast_out,"\tDatabase contains %d sequences, %lld residues\n\n", db->seq_count, db->residue_count);
   }
   /* print handling of DNA strands */
   if (ps->strand_handling == Combine) {
@@ -740,7 +740,7 @@
       MAST_MOTIF_T *m = h->motif;
       int ws = (translate_dna ? 3 * m->width : m->width);
       //the plus 1 is needed because pos counts from 1
-      printed = snprintf(tmp+pos, remaining, "_%ld", length - h->pos - ws + 1);
+      printed = snprintf(tmp+pos, remaining, "_%lld", length - h->pos - ws + 1);
       if (printed >= remaining) {
         if (pos == 0) die("make_diagram: tmp buffer too small\n");
         break;
@@ -762,7 +762,7 @@
       m = h->motif;
       if (mode == -1) {
         if (h->gap == 0) continue;
-        printed = snprintf(tmp+pos, remaining, "_%ld", h->gap);
+        printed = snprintf(tmp+pos, remaining, "_%lld", h->gap);
       } else {
         char *strand = (strand_handling == Combine ? (h->strand == 1 ? "+" : "-") : "");
         int frame = translate_dna ? h->pos % 3 + 1 : 0;
@@ -820,7 +820,7 @@
     int il = (*st=='\0') ? MAXID : MAXID-2;		/* length of id */
     char *elipsis = strlen(seq->comment) > il ? "... " : "   ";
     if (*frame!='\0') il -= 2;
-    fprintf(ps->hit_file, "%s%-*.*s %-*.*s%3s%s%s  %8.2g %6ld\n", kp, nl, nl, 
+    fprintf(ps->hit_file, "%s%-*.*s %-*.*s%3s%s%s  %8.2g %6lld\n", kp, nl, nl, 
       seq->name, il, il, seq->comment, elipsis, st, frame, score->evalue, seq->length);
   } /* print hit */
 
@@ -859,7 +859,7 @@
       print the length, combined p-value and E-value 
     */
     fprintf(ps->note_file, 
-      "  LENGTH = %ld  COMBINED P-VALUE = %8.2e  E-VALUE = %8.2g\n",
+      "  LENGTH = %lld  COMBINED P-VALUE = %8.2e  E-VALUE = %8.2g\n",
       seq->length, score->combined_pvalue, score->evalue);
 
     /* 
@@ -972,7 +972,7 @@
           print_right_trimmed_string(ps->note_file, translated_line+j, line_width);
           putc('\n', ps->note_file);
         }
-        fprintf(ps->note_file, "%-5ld", seg->start + j);
+        fprintf(ps->note_file, "%-5lld", seg->start + j);
         fprintf(ps->note_file, "%.*s\n", line_width, seq_line+j);
         ++k;
       }
@@ -1276,14 +1276,16 @@
   return 0;
 }
 
-int ld_long(char *value, void *data) {
-  long parsed_value;
+
+
+int ld_llong(char *value, void *data) {
+  long long parsed_value;
   char *end_ptr;
   errno = 0;
-  parsed_value = strtol(value, &end_ptr, 10);
+  parsed_value = strtoll(value, &end_ptr, 10);
   if (end_ptr == value) return -1;
   if (errno) return errno;
-  *((long*)data) = parsed_value;
+  *((long long*)data) = parsed_value;
   return 0;
 }
 
@@ -1696,7 +1698,7 @@
   MULTI_T multi_type = {.count = 2, .options = opts_type, .outputs = outs_type, .target = &(db->is_dna)};
 
   char *names[8] = {"id", "last_mod_date", "name", "num", "residue_count", "seq_count", "source", "type"};
-  int (*parsers[8])(char*, void*) = {ld_str, ld_str, ld_str, ld_int, ld_long, ld_int, ld_str, ld_multi};
+  int (*parsers[8])(char*, void*) = {ld_str, ld_str, ld_str, ld_int, ld_llong, ld_int, ld_str, ld_multi};
   void *data[8] = {&(db->id), &(db->last_mod_date), &(db->name), &(db->num), &(db->residue_count), &(db->seq_count), &(db->source), &multi_type};
   BOOLEAN_T required[8] = {TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE};
   parse_attributes(ps, "database", attrs, 8, names, parsers, data, required);
@@ -1719,7 +1721,7 @@
   seq->has_score2 = FALSE;
 
   char *names[6] = {"comment","db","id","length","name", "num"};
-  int (*parsers[6])(char*, void*) = {ld_str, ld_str, ld_str, ld_long, ld_str, ld_int};
+  int (*parsers[6])(char*, void*) = {ld_str, ld_str, ld_str, ld_llong, ld_str, ld_int};
   void *data[6] = {&(seq->comment), &db_id, &(seq->id), &(seq->length), &(seq->name), &(seq->num)};
   BOOLEAN_T required[6] = {FALSE, TRUE, TRUE, TRUE, TRUE, TRUE};
   parse_attributes(ps, "sequence", attrs, 6, names, parsers, data, required);
@@ -1782,7 +1784,7 @@
   memset(seg, 0, sizeof(SEG_T));
   
   char *names[1] = {"start"};
-  int (*parsers[1])(char*, void*) = {ld_long};
+  int (*parsers[1])(char*, void*) = {ld_llong};
   void *data[1] = {&(seg->start)};
   BOOLEAN_T required[1] = {TRUE};
   parse_attributes(ps, "seg", attrs, 1, names, parsers, data, required);
@@ -1815,7 +1817,7 @@
 
   char *motif_id = NULL;
   char *names[7] = {"gap", "match", "motif", "pos", "pvalue", "strand", "translation"};
-  int (*parsers[7])(char*, void*) = {ld_long, ld_str, ld_str, ld_long, ld_double, ld_multi, ld_str};
+  int (*parsers[7])(char*, void*) = {ld_llong, ld_str, ld_str, ld_llong, ld_double, ld_multi, ld_str};
   void *data[7] = {&(hit->gap), &(hit->match), &(motif_id), &(hit->pos), &(hit->pvalue), &multi_strand, &(hit->translated)};
   BOOLEAN_T required[7] = {TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, ps->translate_dna};
   parse_attributes(ps, "hit", attrs, 7, names, parsers, data, required);
@@ -1828,7 +1830,7 @@
     } else if (hit->pos < seg->start) {
       //check that the position is within the bounds of the segment
       ps->state = PS_ERROR;
-      DEBUG_FMT(QUIET_VERBOSE, "hit::pos (%ld) is before the start (%ld) of the segment\n", hit->pos, seg->start);
+      DEBUG_FMT(QUIET_VERBOSE, "hit::pos (%lld) is before the start (%lld) of the segment\n", hit->pos, seg->start);
     } else if ((hit->pos - seg->start) + hit->motif->ws > seg->length) {
       //check that the hit ends before the bounds of the segment
       ps->state = PS_ERROR;
diff -r 1f1e06a05c93 -r d93b2a812916 src/read_sequence.c
--- a/src/read_sequence.c	Thu Nov 08 12:00:17 2012 +1000
+++ b/src/read_sequence.c	Tue Nov 13 19:30:07 2012 +1000
@@ -194,6 +194,7 @@
                                    string will be appended */
 )
 {
+  static int seen_truncate_warning = 0;
   int length, real_length, c;
   char *de = *descriptor;
 
@@ -223,12 +224,14 @@
   de[length] = '\0';
 
   *descriptor = de;
-  if (length != real_length) {
+  if (length != real_length && !seen_truncate_warning) {
     fprintf(stderr, "\nWarning: The sequence description was could not be "
         "completely stored. MEME stored %d characters but the description was "
         "%d characters long. To fix this problem increase the constant "
-        "MAXDELEN in the file read_sequence.h and recompile.\n", length, 
+        "MAXDELEN in the file read_sequence.h and recompile. This warning will "
+        "not be repeated for any further description truncations.\n", length, 
         real_length);
+    seen_truncate_warning = 1;
   }
 
   return length;
diff -r 1f1e06a05c93 -r d93b2a812916 src/xml-out.c
--- a/src/xml-out.c	Thu Nov 08 12:00:17 2012 +1000
+++ b/src/xml-out.c	Tue Nov 13 19:30:07 2012 +1000
@@ -7,9 +7,91 @@
  * DESCRIPTION: Utility functions for writing XML files.
  **************************************************************************/
 #include <assert.h>
+#include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 
+#define BYTETOBINARYPATTERN "%d%d%d%d%d%d%d%d"
+#define BYTETOBINARY(byte)  \
+  (byte & 0x80 ? 1 : 0), \
+  (byte & 0x40 ? 1 : 0), \
+  (byte & 0x20 ? 1 : 0), \
+  (byte & 0x10 ? 1 : 0), \
+  (byte & 0x08 ? 1 : 0), \
+  (byte & 0x04 ? 1 : 0), \
+  (byte & 0x02 ? 1 : 0), \
+  (byte & 0x01 ? 1 : 0) 
+
+/*
+ * Reads a UTF-8 codepoint. The string must be null terminated.
+ */
+static inline int read_utf8_codepoint(char *str, uint32_t *codepoint_out) {
+  unsigned char byte;
+  uint32_t codepoint;
+  int bytes, i;
+  byte = *str;
+  if (byte & 0x80) {// UTF-8 multibyte
+    // determine the number of bytes in the multibyte
+    if ((byte & 0xE0) == 0xC0) {
+      bytes = 2;
+      codepoint = ((uint32_t)(byte & 31)) << 6;
+    } else if ((byte & 0xF0) == 0xE0) {
+      bytes = 3;
+      codepoint = ((uint32_t)(byte & 15)) << 12;
+    } else if ((byte & 0xF8) == 0xF0) {
+      bytes = 4;
+      codepoint = ((uint32_t)(byte & 7)) << 18;
+    } else if ((byte & 0xFC) == 0xF8) {
+      bytes = 5;
+      codepoint = ((uint32_t)(byte & 3)) << 24;
+    } else if ((byte & 0xFE) == 0xFC) {
+      bytes = 6;
+      codepoint = ((uint32_t)(byte & 1)) << 30;
+    } else { // bad byte!
+      if ((byte & 0xC0) == 0x80) {
+        fprintf(stderr, "The bit pattern 10xxxxxx is illegal for the first "
+            "byte of a UTF-8 multibyte.\n");
+      } else if (byte == 0xFE) {
+        fprintf(stderr, "The byte 0xFE is illegal for UTF-8.\n");
+      } else {
+        fprintf(stderr, "The byte 0xFF is illegal for UTF-8.\n");
+      } 
+      exit(1);
+      // stop compiler complaints
+      bytes = 1;
+      codepoint = 0;
+    }
+    // read the rest of the bytes
+    for (i = 1; i < bytes; i++) {
+      if (str[i] == '\0') {
+        return i - bytes;
+      }
+      byte = str[i];
+      if ((byte & 0xC0) != 0x80) {
+        fprintf(stderr, "Expected the bit pattern 10xxxxxx for a following "
+            "byte of a UTF-8 multibyte.\n");
+        exit(1);
+      }
+      codepoint = codepoint | (((uint32_t)(byte & 0x3F)) << (6 * (bytes - i - 1)));
+    }
+    // check for overlong representations by seeing if we could have represented
+    // the number with one less byte
+    if (bytes > 1 && codepoint < (1 << (bytes == 2 ? 7 : (6 * (bytes - 2) + (8 - bytes))))) {
+      fprintf(stderr, "The UTF-8 multibyte uses too many bytes (%d) for the "
+          "codepoint (%zu) it represents.\n", bytes, codepoint);
+      for (i = 0; i < bytes; i++) {
+        fprintf(stderr, BYTETOBINARYPATTERN " ", BYTETOBINARY((unsigned char)str[i]));
+      }
+      fputs("\n", stderr);
+      exit(1);
+    }
+  } else { // ASCII byte
+    bytes = 1;
+    codepoint = byte;
+  }
+  *codepoint_out = codepoint;
+  return bytes;
+}
 
 /**********************************************************************/
 /*
@@ -25,22 +107,50 @@
  */
 /**********************************************************************/
 char* replace_xml_chars(char *input, char *buffer, int buffer_size, int replace_quote, int *extra) {
-  int i, j, k;
+  int i, j, k, used;
   char *copy;
-  for (i = 0, j = 0; input[i] != '\0'; ++i) {
+  uint32_t cp;
+  for (i = 0, j = 0, used = 1, cp = 0; input[i] != '\0'; i += used) {
+    used = read_utf8_codepoint(input+i, &cp);
+    if (used <= 0) break;
     //put the next item to be copied across into the copy string
-    switch (input[i]) {
+    switch (cp) {
       case '&': copy = "&amp;"; break;
       case '<': copy = "&lt;"; break;
       case '>': copy = "&gt;"; break;
+      case 9: 
+        if (!replace_quote) goto dupe_codepoint;
+        copy = "&#9;"; break;
+      case 10:
+        if (!replace_quote) goto dupe_codepoint;
+        copy = "&#10;"; break;
+      case 13:
+        if (!replace_quote) goto dupe_codepoint;
+        copy = "&#13;"; break;
       case '"':
-        if (replace_quote) {
-          copy = "&quot;"; break;
+        if (!replace_quote) goto dupe_codepoint;
+        copy = "&quot;"; break;
+      default://copy across the character (if possible)
+        // check that the codepoint can be represented in XML 1.0
+        // It must be within the allowed ranges:
+        // U+0009, U+000A, U+000D (these three are handled above)
+        // U+0020–U+D7FF, U+E000–U+FFFD
+        // U+10000–U+10FFFF
+        // also not in the discouraged ranges:
+        // U+007F–U+0084, U+0086–U+009F
+        // 
+        if (!((cp >= 20 && cp < 127) || (cp > 132 && cp < 134) || 
+            (cp > 159 && cp <= 55295) || (cp >= 57344 && cp <= 65533) ||
+            (cp >= 65536 && cp <= 1114111))) {
+          // not possible to represent! skip!
+          continue;
         }
-      //fall through
-      default://copy across the character (if possible)
-        if (j < buffer_size) buffer[j] = input[i];
-        ++j; continue;
+dupe_codepoint:
+        if ((j + used) <= buffer_size) {
+          for (k = 0; k < used; k++) buffer[j+k] = input[i+k];
+        }
+        j += used;
+        continue;
     }
     //copy the item into the buffer
     for (k = 0; copy[k] != '\0'; ++k, ++j) {
diff -r 1f1e06a05c93 -r d93b2a812916 website/cgi-bin/fimo.pl
--- a/website/cgi-bin/fimo.pl	Thu Nov 08 12:00:17 2012 +1000
+++ b/website/cgi-bin/fimo.pl	Tue Nov 13 19:30:07 2012 +1000
@@ -228,7 +228,7 @@
     # get the sequences name
     $d{UPSEQS_ORIG_NAME} = fileparse($q->param('upload_db'));
     $d{UPSEQS_NAME} = get_safe_file_name($d{UPSEQS_ORIG_NAME}, 'uploaded', 2);
-  } elsif ($q->param('database')) {
+  } elsif (defined scalar $q->param('database')) {
     my $dbid = $utils->param_require($q, 'database');
     if ($dbid =~ m/^\d+$/) {
       $logger->trace("call load_entry") if $logger;
diff -r 1f1e06a05c93 -r d93b2a812916 website/cgi-bin/glam2scan.pl
--- a/website/cgi-bin/glam2scan.pl	Thu Nov 08 12:00:17 2012 +1000
+++ b/website/cgi-bin/glam2scan.pl	Tue Nov 13 19:30:07 2012 +1000
@@ -214,7 +214,7 @@
     # get the sequences name
     $d{UPSEQS_ORIG_NAME} = fileparse($q->param('upload_db'));
     $d{UPSEQS_NAME} = get_safe_file_name($d{UPSEQS_ORIG_NAME}, 'uploaded', 2);
-  } elsif ($q->param('database')) {
+  } elsif (defined scalar $q->param('database')) {
     my $dbid = $utils->param_require($q, 'database');
     if ($dbid =~ m/^\d+$/) {
       $logger->trace("call load_entry") if $logger;
diff -r 1f1e06a05c93 -r d93b2a812916 website/cgi-bin/gomo.pl
--- a/website/cgi-bin/gomo.pl	Thu Nov 08 12:00:17 2012 +1000
+++ b/website/cgi-bin/gomo.pl	Tue Nov 13 19:30:07 2012 +1000
@@ -215,7 +215,7 @@
   $d{DB_MULTI} = $utils->param_bool($q, 'multispecies');
 
   # get the database
-  if ($q->param('database')) {
+  if (defined scalar $q->param('database')) {
     my $dbid = $utils->param_require($q, 'database');
     if ($dbid =~ m/^\d+$/) {
       my @entry = load_entry($INDEX_PATH, $dbid);
diff -r 1f1e06a05c93 -r d93b2a812916 website/cgi-bin/mast.pl
--- a/website/cgi-bin/mast.pl	Thu Nov 08 12:00:17 2012 +1000
+++ b/website/cgi-bin/mast.pl	Tue Nov 13 19:30:07 2012 +1000
@@ -251,7 +251,7 @@
     # get the sequences name
     $d{SEQS_ORIG_NAME} = fileparse($q->param('upload_db'));
     $d{SEQS_NAME} = get_safe_file_name($d{SEQS_ORIG_NAME}, 'uploaded', 2);
-  } elsif ($q->param('database')) {
+  } elsif (defined scalar $q->param('database')) {
     my $dbid = $utils->param_require($q, 'database');
     if ($dbid =~ m/^\d+$/) {
       $logger->trace("call load_entry") if $logger;
diff -r 1f1e06a05c93 -r d93b2a812916 website/cgi-bin/mcast.pl
--- a/website/cgi-bin/mcast.pl	Thu Nov 08 12:00:17 2012 +1000
+++ b/website/cgi-bin/mcast.pl	Tue Nov 13 19:30:07 2012 +1000
@@ -235,7 +235,7 @@
     # get the sequences name
     $d{UPSEQS_ORIG_NAME} = fileparse($q->param('upload_db'));
     $d{UPSEQS_NAME} = get_safe_file_name($d{UPSEQS_ORIG_NAME}, 'uploaded', 2);
-  } elsif ($q->param('database')) {
+  } elsif (defined scalar $q->param('database')) {
     my $dbid = $utils->param_require($q, 'database');
     if ($dbid =~ m/^\d+$/) {
       $logger->trace("call load_entry") if $logger;
